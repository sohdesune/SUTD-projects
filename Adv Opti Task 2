# Specify term (5 or 7) and half (1 or 2) to solve for
solve_term = 5
solve_half = 1

T = 92 # the last time-index, corresponding to the Fri 1300-1330 timeslot
EOD_timings = [24, 48, 58, 82, 92] # last time-index of each day
venue_overlap = {6:[4,5], 32:[30,31]} # e.g. 1.415/1.416: [1.415, 1.416]

#############################################################################
import gurobipy as gp
from gurobipy import GRB
import pandas as pd
import os
import warnings
import re

### Read data to dataframe and create multidict #############################
#os.chdir("set your wd here")
ttdata_full = pd.read_csv('TT Data v5.csv')
ttdata_otherpillars = pd.read_csv('TT_NonESD_Data.csv')

assert type(solve_term) == int and type(solve_half) == int
with warnings.catch_warnings():
	warnings.simplefilter("ignore")

	ttdata_half = ttdata_full[ttdata_full["term_half"]==solve_half]
	ttdata_T5 = ttdata_half[ttdata_half["term"]=="ESD T5"].reset_index() # T5 only
	ttdata_T7 = ttdata_half[ttdata_half["term"]!="ESD T5"].reset_index() # T7 & TAE only

	ttdata_other_half = ttdata_otherpillars[ttdata_otherpillars["term_half"]==solve_half]

if solve_term == 5:
	df = ttdata_T5
else:
	df = ttdata_T7

# multidict for ESD subjects
jobs, proc, instructor, venue, subject, prec, class_num = gp.multidict({
	df["job_ix"][i]: [
		df["proc_time"][i],
		df["instructor"][i],
		df["venue_ix"][i],
		df["subject_ix"][i],
		df["precedence"][i],
		df["class_num"][i]
	] for i in range(len(df))
})

# multidict for non-ESD subjects
blocker, non_ESD_venue, block_start, block_end = gp.multidict({
	ttdata_other_half["blocker"][i]: [
		ttdata_other_half["venue_ix"][i],
		ttdata_other_half["release_date"][i],
		ttdata_other_half["deadline"][i]
	] for i in range(len(ttdata_other_half))
})

print("\nRead data into multidict for Term %d" % solve_term)

### Create Gurobi model and define variables ################################
completion_time = {(j,v,t): t + proc[j] for j in jobs for v in set(venue.values()) for t in range(1,T+1)}

print("Problem space: %d ESD jobs x %d venues x %d time indices = %d\n"
% (len(jobs), len(set(venue.values())), T, len(jobs)*len(set(venue.values()))*T))

print("Creating Gurobi model:")
m = gp.Model("Adv Opti Task 2 by Kutosotase 2021")
X = m.addVars(completion_time.keys(), vtype=GRB.BINARY, name="X")

# Variables to ensure classes of a subject are spread out across days
EOD_splits = [(j,k,t) for j in jobs for k in jobs for t in range(4)]
E = m.addVars(EOD_splits, vtype=GRB.BINARY, name="E")

# Define objective function #################################################

if solve_term == 5:
	df_core = df[df["track_core"]==1].reset_index()
	jobs_core = [df_core["job_ix"][i] for i in range(len(df_core))]
	m.setObjective(gp.quicksum(X[j,v,t]*completion_time[j,v,t] for j in jobs_core for v in set(venue.values()) for t in range(1,T+1)), GRB.MINIMIZE)
else:
	tracks = ["track_avi", "track_ba", "track_fin", "track_scl", "track_uis"]
	all_tracks_sums = []
	
	for track in tracks:
		df_track = df[df[track]==1].reset_index()
		track_jobs = [df_track["job_ix"][i] for i in range(len(df_track))]

		track_sum = gp.quicksum(X[j,v,t]*completion_time[j,v,t] for j in track_jobs for v in set(venue.values()) for t in range(1,T+1))
		all_tracks_sums.append(track_sum)
	
	print("\n\n\nterm 7 obj func needs to change\n\n\n")
	z_term7 = 0
	m.addConstr((z_term7 == gp.max_(all_tracks_sums)), "obj func for Term 7")
	m.setObjective(z_term7, GRB.MINIMIZE)

print("\nObjective function defined")

### Define constraints ######################################################

### All classes must be assigned
m.addConstrs((X.sum(j,"*","*")==1 for j in jobs), "all jobs assigned")

### At most 1 class at any venue at any time instant
for v in set(venue.values()):
	for t in range(1,T+1):
		jobs_in_venue = 0
		for j in jobs:
			for s in range(max(1,t+1-proc[j]), t+1):
				jobs_in_venue += X[j,v,s]
		m.addConstr(jobs_in_venue <= 1, "<=1 job per venue per time")

### At most 1 class per instructor at any time instant
for instr in set(instructor.values()):
	jobs_under_instructor = [j for j in jobs if instructor[j]==instr]
	#print("%s %s" % (instr, jobs_under_instructor))

	for t in range(1,T+1):
		jobs_being_done = 0
		for j in jobs_under_instructor:
			for s in range(max(1,t+1-proc[j]), t+1):
				jobs_being_done += X.sum(j,"*",s)
		m.addConstr(jobs_being_done <= 1, "<=1 job per prof per time")

### Venues are blocked by other pillars/HASS
for v in set(venue.values()):
	for b in blocker:
		if v == non_ESD_venue[b]:
			m.addConstrs((X.sum("*",v,t)==0 for t in range(block_start[b], block_end[b]+1)), "venues blocked by other pillars")

### Venues are blocked by EOD
m.addConstrs((X.sum("*","*",t)==0 for t in EOD_timings), "venues blocked by EOD")

### Precedence constraints within the same subject & At most one session of each subject in a day
lecture_str = re.compile("L")
for j in jobs:
	for k in jobs:
		if j != k and subject[j] == subject[k] and prec[j] < prec[k]:
			# If same cohort (e.g. both CS01) or either class is a lecture
			if class_num[j]==class_num[k] or bool(lecture_str.search(class_num[j])) or bool(lecture_str.search(class_num[k])):
				# Then constrain j to precede k
				m.addConstr(sum(X.sum(j,"*",t)*t for t in range(1,T+1)) + 1 <= sum(X.sum(k,"*",t)*t for t in range(1,T+1)), "precedence constr")
			
			# j must be before some EOD block, and k after that same block
			for eod in range(4):
				m.addConstr(sum(X.sum(j,"*",t)*t for t in range(1,T+1)) <= EOD_timings[eod] + (1-E[j,k,eod])*T)
				m.addConstr(sum(X.sum(k,"*",t)*t for t in range(1,T+1)) >= EOD_timings[eod] - (1-E[j,k,eod])*T)

			# Exactly one EOD block must be "sandwiched" at a time
			m.addConstr(sum(E[j,k,eod] for eod in range(4)) == 1)

### 2.503/2.504 blocks 2.503 and 2.504, vice versa
for key, vals in venue_overlap.items():
	for val in vals:
		m.addConstrs((X.sum("*",key,t)+(X.sum("*",val,t))<=1 for t in range(1,T+1)), "venue overlaps")

### Sessions must occupy the venue stipulated in the original timetable
for j in jobs:
	for v in set(venue.values()):
		m.addConstrs(X[j,v,t]==0 for t in range(1,T+1) if v != venue[j])

### WORK IN PROGRESS 15 FEB 9PM
### Sessions for subjects in the same focus track do not clash
### There is at least a 30min break between sessions for subjects in the same track

print("Constraints defined, starting optimization\n")

### Solve and print results #################################################
m.optimize()
for x in X.values():
	if (x.x > 0.5): print("%s %g" % (x.varName, x.x)) # print decision variables that equal 1
print("Obj: %g" % m.objVal)
